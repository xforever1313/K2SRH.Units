using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace K2SRH.Units.Generator
{
    [Generator]
    public sealed class OperatorGenerator : IIncrementalGenerator
    {
        // ---------------- Methods ----------------

        public void Initialize( IncrementalGeneratorInitializationContext context )
        {
            var candidates = context.SyntaxProvider
                .CreateSyntaxProvider(
                    ( node, _ ) => node is StructDeclarationSyntax cds && cds.AttributeLists.Count > 0,
                    ( ctx, ct ) => GetAnnotatedClass( ctx, ct )
                )
                .Where( s => ( s is null ) == false );

            // Deduplicate symbols
            var unique = candidates.Collect();

            context.RegisterSourceOutput(
                unique,
                ( spc, list ) =>
                {
                    var seen = new HashSet<string>( StringComparer.Ordinal );

                    foreach( var symbol in list )
                    {
                        if( symbol is INamedTypeSymbol type )
                        {
                            var key = type.ToDisplayString( SymbolDisplayFormat.FullyQualifiedFormat );

                            if( seen.Add( key ) == false )
                            {
                                continue;
                            }
                            GenerateFor( spc, type );
                        }
                    }
                }
            );
        }

        private static INamedTypeSymbol GetAnnotatedClass( GeneratorSyntaxContext context, CancellationToken ct )
        {
            StructDeclarationSyntax sds = (StructDeclarationSyntax)context.Node;
            INamedTypeSymbol symbol = context.SemanticModel.GetDeclaredSymbol( sds, ct );
            if( symbol is null )
            {
                return null;
            }

            // Look for [Units] or [UnitsAttribute]
            var hasUnits = symbol.GetAttributes().Any(
                a =>
                {
                    var name = a.AttributeClass?.Name;
                    return string.Equals( name, "BaseUnitAttribute", StringComparison.Ordinal )
                        || string.Equals( name, "BaseUnit", StringComparison.Ordinal );
                }
            );

            return hasUnits ? symbol : null;
        }

        private static void GenerateFor( SourceProductionContext spc, INamedTypeSymbol type )
        {
            // Find value field.
            ITypeSymbol valueType = FindValueType( type );
            if( valueType is null )
            {
                throw new Exception(
                    $"Could not find a field for type {type.Name}.  Please add one and make sure it is decimal type."
                );
            }

            var source = BuildSource( type, valueType );
            var hint = MakeHintName( type );
            spc.AddSource( hint, source );
        }

        private static ITypeSymbol FindValueType( INamedTypeSymbol t )
        {
            var field = t.GetMembers( "value" ).OfType<IFieldSymbol>().FirstOrDefault();
            return field?.Type;
        }

        private static string BuildSource( INamedTypeSymbol type, ITypeSymbol valueType )
        {
            return $@"
// <auto-generated/>
using System;

namespace K2SRH.Units
{{
    public partial struct {type.Name} : IEquatable<{type.Name}>, IComparable<{type.Name}>
    {{
        // ---------------- Fields ----------------

        public static readonly {type.Name} Zero = new {type.Name}( 0 );

        // ---------------- Methods ----------------

        public static {type.Name} Abs( {type.Name} unit )
        {{
            return new {type.Name}( Math.Abs( unit.value ) );
        }}

        public bool Equals( {type.Name} other )
        {{
            return this.value == other.value;
        }}

        public override bool Equals( object obj )
        {{
            if( obj is {type.Name} unit )
            {{
                return Equals( unit );
            }}
            else
            {{
                return false;
            }}
        }}

        public override int GetHashCode()
        {{
            return this.value.GetHashCode();
        }}

        public static bool operator ==( {type.Name} left, {type.Name} right )
        {{
            return left.value == right.value;
        }}

        public static bool operator !=( {type.Name} left, {type.Name} right )
        {{
            return left.value != right.value;
        }}

        public int CompareTo( {type.Name} other )
        {{
            return this.value.CompareTo( other.value );
        }}

        public static bool operator > ( {type.Name} left, {type.Name} right )
        {{
            return left.value > right.value;
        }}

        public static bool operator < ( {type.Name} left, {type.Name} right )
        {{
            return left.value < right.value;
        }}

        public static bool operator >= ( {type.Name} left, {type.Name} right )
        {{
            return left.value >= right.value;
        }}

        public static bool operator <= ( {type.Name} left, {type.Name} right )
        {{
            return left.value <= right.value;
        }}

        public static {type.Name} operator +( {type.Name} left, {type.Name} right )
        {{
            return new {type.Name}( left.value + right.value );
        }}

        public static {type.Name} operator -( {type.Name} left, {type.Name} right )
        {{
            return new {type.Name}( left.value - right.value );
        }}

        public static {type.Name} operator *( {type.Name} left, {type.Name} right )
        {{
            return new {type.Name}( left.value * right.value );
        }}

        public static {type.Name} operator /( {type.Name} left, {type.Name} right )
        {{
            return new {type.Name}( left.value / right.value );
        }}
    }}
}}
";
        }

        private static string MakeHintName( INamedTypeSymbol type )
        {
            var name = type.ToDisplayString( SymbolDisplayFormat.FullyQualifiedFormat )
                .Replace( "global::", "" )
                .Replace( '.', '_' )
                .Replace( '<', '_' )
                .Replace( '>', '_' )
                .Replace( ',', '_' )
                .Replace( ' ', '_' );
            return $"{name}_UnitsOperator.g.cs";
        }
    }
}
