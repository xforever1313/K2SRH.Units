//
//          Copyright Seth Hendrick 2025.
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          http://www.boost.org/LICENSE_1_0.txt)
//

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace K2SRH.Units.Generator
{
    [Generator]
    public sealed class UnitGenerator : IIncrementalGenerator
    {
        // ---------------- Methods ----------------

        public void Initialize( IncrementalGeneratorInitializationContext context )
        {
            var candidates = context.SyntaxProvider
                .CreateSyntaxProvider(
                    ( node, _ ) => node is StructDeclarationSyntax cds && cds.AttributeLists.Count > 0,
                    ( ctx, ct ) => GetAnnotatedClass( ctx, ct )
                )
                .Where( s => ( s is null ) == false );

            // Deduplicate symbols
            var unique = candidates.Collect();

            context.RegisterSourceOutput(
                unique,
                ( spc, list ) =>
                {
                    var seen = new HashSet<string>( StringComparer.Ordinal );

                    foreach( var symbol in list )
                    {
                        if( symbol is INamedTypeSymbol type )
                        {
                            var key = type.ToDisplayString( SymbolDisplayFormat.FullyQualifiedFormat );

                            if( seen.Add( key ) == false )
                            {
                                continue;
                            }
                            GenerateFor( spc, type );
                        }
                    }
                }
            );
        }

        private static INamedTypeSymbol GetAnnotatedClass( GeneratorSyntaxContext context, CancellationToken ct )
        {
            StructDeclarationSyntax sds = (StructDeclarationSyntax)context.Node;
            INamedTypeSymbol symbol = context.SemanticModel.GetDeclaredSymbol( sds, ct );
            if( symbol is null )
            {
                return null;
            }

            if( GetUnitsType( symbol ).Any() )
            {
                return symbol;
            }
            else
            {
                return null;
            }
        }

        private static List<ITypeSymbol> GetUnitsType( INamedTypeSymbol targetType )
        {
            IEnumerable<AttributeData> attributes = targetType.GetAttributes().Where(
                a => ( "UnitAttribute" == a?.AttributeClass?.Name ) || ( "Unit" == a?.AttributeClass?.Name )
            );

            var typeSymbols = new List<ITypeSymbol>();
            foreach( AttributeData attribute in attributes )
            {
                // Should never happen, we should get compiler error anyways.
                // There is only one constructor with one argument.
                if( attribute.ConstructorArguments.Length != 1 )
                {
                    continue;
                }

                // This will only work for positional arguments;
                // which the libary only uses anyways.
                TypedConstant type = attribute.ConstructorArguments[0];
                if( type.Kind == TypedConstantKind.Type && type.Value is ITypeSymbol typeSymbol )
                {
                    typeSymbols.Add( typeSymbol );
                }
            }

            return typeSymbols;
        }

        private static void GenerateFor( SourceProductionContext spc, INamedTypeSymbol type )
        {
            var source = BuildSource( type );
            var hint = MakeHintName( type );
            spc.AddSource( hint, source );
        }

        private static string BuildSource( INamedTypeSymbol unitType )
        {
            List<ITypeSymbol> units = GetUnitsType( unitType );
            if( units.Any() == false )
            {
                return $"#error {unitType.Name} did not produce any unit types?";
            }

            var sourceBuilder = new StringBuilder();

            sourceBuilder.AppendLine( "// <auto-generated/>" );
            sourceBuilder.AppendLine( "using System;" );
            sourceBuilder.AppendLine( "namespace K2SRH.Units" );
            sourceBuilder.AppendLine( "{" );

            sourceBuilder.AppendLine( $"    public partial struct {unitType.Name}" );
            sourceBuilder.AppendLine( $"    {{" );
            sourceBuilder.AppendLine( $"        // ---------------- Constructor ----------------" );
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine( $"        public {unitType.Name}( decimal {unitType.Name.ToLower()} )" );
            sourceBuilder.AppendLine( $"        {{" );
            sourceBuilder.AppendLine( $"            this.Value = {unitType.Name.ToLower()};" );
            sourceBuilder.AppendLine( $"        }}" );
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine( $"        // ---------------- Properties ----------------" );
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine( $"        public decimal Value {{ get; }}" );
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine( $"        // ---------------- Methods ----------------" );
            sourceBuilder.AppendLine();

            foreach( ITypeSymbol typeSymbol in units )
            {
                sourceBuilder.AppendLine( GenerateUnitMethods( unitType, typeSymbol ) );
            }

            sourceBuilder.AppendLine( $"    }}" );

            foreach( ITypeSymbol typeSymbol in units )
            {
                sourceBuilder.AppendLine( GenerateExtensionMethods( unitType, typeSymbol ) );
            }

            sourceBuilder.AppendLine( "}" );

            return sourceBuilder.ToString();
        }

        private static string GenerateUnitMethods( INamedTypeSymbol unitType, ITypeSymbol measurementType )
        {
            return $@"
        // -------- {measurementType.Name} --------
";
        }

        private static string GenerateExtensionMethods( INamedTypeSymbol unitType, ITypeSymbol measurementType )
        {
            // Crappy hack for TimeSpans, which are backed by doubles.
            bool isTimeSpan = measurementType.Name == nameof( TimeSpan );
            string timeSpanPrefix = isTimeSpan ? "Total" : "";

            string getValueSignature = $"{unitType.Name}Extensions.{unitType.Name}( {measurementType.Name.ToLower()} )";

            return $@"
    public static partial class {unitType.Name}Extensions
    {{
        /// <summary>
        /// Gets the underlying value of this unit as a double.
        /// </summary>
        public static double {timeSpanPrefix}{unitType.Name}AsDouble( this {measurementType.Name} {measurementType.Name.ToLower()} )
        {{
            return decimal.ToDouble( {getValueSignature} );
        }}

        /// <summary>
        /// Gets the underlying value of this unit as an int32. Any fractional digits
        /// are truncated (no rounding happens).
        /// </summary>
        public static int {timeSpanPrefix}{unitType.Name}AsInt32( this {measurementType.Name} {measurementType.Name.ToLower()} )
        {{
            return decimal.ToInt32( {getValueSignature} );
        }}

        public static {unitType.Name} To{timeSpanPrefix}{unitType.Name}( this {measurementType.Name} {measurementType.Name.ToLower()} )
        {{
            return new {unitType.Name}( {getValueSignature} );
        }}

        /// <summary>
        /// Checks to see if the given measurement's value is a whole number of this unit type
        /// (as in, no fractional parts).
        /// </summary>
        /// <returns>
        /// True if there's no fractional component after converting to the unit,
        /// otherwise false.
        /// </returns>
        public static bool IsWhole{unitType.Name}( this {measurementType.Name} {measurementType.Name.ToLower()} )
        {{
            decimal value = {getValueSignature};
            return decimal.Truncate( value ) == value;
        }}

        /// <summary>
        /// Rounds the given <see cref=""{measurementType.Name}""/> to the nearest <see cref=""{unitType.Name}""/>.
        /// </summary>
        /// <returns>
        /// The nearest whole <see cref=""{unitType.Name}""/>.  If the fractional component of the unit
        /// is halfway between two whole units, one of which is even and ht other odd, the event number
        /// is returned.
        /// </returns>
        public static {unitType.Name} RoundToNearest{unitType.Name}( this {measurementType.Name} {measurementType.Name.ToLower()} )
        {{
            decimal roundedValue = Math.Round( {getValueSignature} );
            return new {unitType.Name}( roundedValue );
        }}

        /// <summary>
        /// Rounds the given <see cref=""{measurementType.Name}""/> to the nearest <see cref=""{unitType.Name}""/>.
        /// </summary>
        /// <param name=""decimals"">
        /// The number of decimal places in the return value.
        /// </param>
        /// <returns>
        /// The nearest whole <see cref=""{unitType.Name}""/>.  If the fractional component of the unit
        /// is halfway between two whole units, one of which is even and ht other odd, the event number
        /// is returned.  If the unit has fewer fractional digits than decimals, it is returned unchanged.
        /// </returns>
        public static {unitType.Name} RoundToNearest{unitType.Name}( this {measurementType.Name} {measurementType.Name.ToLower()}, int decimals )
        {{
            decimal roundedValue = Math.Round( {getValueSignature}, decimals );
            return new {unitType.Name}( roundedValue );
        }}

        /// <summary>
        /// Rounds the given <see cref=""{measurementType.Name}""/> to the nearest <see cref=""{unitType.Name}""/>.
        /// </summary>
        /// <param name=""mode"">
        /// Specification for how to round the unit if it is midway between two other numbers.
        /// </param>
        /// <returns>
        /// The nearest whole <see cref=""{unitType.Name}""/>.
        /// </returns>
        public static {unitType.Name} RoundToNearest{unitType.Name}( this {measurementType.Name} {measurementType.Name.ToLower()}, MidpointRounding mode )
        {{
            decimal roundedValue = Math.Round( {getValueSignature}, mode );
            return new {unitType.Name}( roundedValue );
        }}

        /// <summary>
        /// Rounds the given <see cref=""{measurementType.Name}""/> to the nearest <see cref=""{unitType.Name}""/>.
        /// </summary>
        /// <param name=""decimals"">
        /// The number of decimal places in the return value.
        /// </param>
        /// <param name=""mode"">
        /// Specification for how to round the unit if it is midway between two other numbers.
        /// </param>
        /// <returns>
        /// The nearest whole <see cref=""{unitType.Name}""/>.
        /// If the unit has fewer fractional digits than decimals, it is returned unchanged.
        /// </returns>
        public static {unitType.Name} RoundToNearest{unitType.Name}( this {measurementType.Name} {measurementType.Name.ToLower()}, int decimals, MidpointRounding mode )
        {{
            decimal roundedValue = Math.Round( {getValueSignature}, decimals, mode );
            return new {unitType.Name}( roundedValue );
        }}
    }}
";
        }

        private static string MakeHintName( INamedTypeSymbol type )
        {
            var name = type.ToDisplayString( SymbolDisplayFormat.FullyQualifiedFormat )
                .Replace( "global::", "" )
                .Replace( '.', '_' )
                .Replace( '<', '_' )
                .Replace( '>', '_' )
                .Replace( ',', '_' )
                .Replace( ' ', '_' );
            return $"{name}_UnitsOperator.g.cs";
        }
    }
}
