//
//          Copyright Seth Hendrick 2025.
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          http://www.boost.org/LICENSE_1_0.txt)
//

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace K2SRH.Units.Generator
{
    [Generator]
    public sealed class UnitGenerator : IIncrementalGenerator
    {
        // ---------------- Methods ----------------

        public void Initialize( IncrementalGeneratorInitializationContext context )
        {
            var candidates = context.SyntaxProvider
                .CreateSyntaxProvider(
                    ( node, _ ) => node is StructDeclarationSyntax cds && cds.AttributeLists.Count > 0,
                    ( ctx, ct ) => GetAnnotatedClass( ctx, ct )
                )
                .Where( s => ( s is null ) == false );

            // Deduplicate symbols
            var unique = candidates.Collect();

            context.RegisterSourceOutput(
                unique,
                ( spc, list ) =>
                {
                    var seen = new HashSet<string>( StringComparer.Ordinal );

                    foreach( var symbol in list )
                    {
                        if( symbol is INamedTypeSymbol type )
                        {
                            var key = type.ToDisplayString( SymbolDisplayFormat.FullyQualifiedFormat );

                            if( seen.Add( key ) == false )
                            {
                                continue;
                            }
                            GenerateFor( spc, type );
                        }
                    }
                }
            );
        }

        private static INamedTypeSymbol GetAnnotatedClass( GeneratorSyntaxContext context, CancellationToken ct )
        {
            StructDeclarationSyntax sds = (StructDeclarationSyntax)context.Node;
            INamedTypeSymbol symbol = context.SemanticModel.GetDeclaredSymbol( sds, ct );
            if( symbol is null )
            {
                return null;
            }

            if( GetUnitsType( symbol ).Any() )
            {
                return symbol;
            }
            else
            {
                return null;
            }
        }

        private static List<ITypeSymbol> GetUnitsType( INamedTypeSymbol targetType )
        {
            IEnumerable<AttributeData> attributes = targetType.GetAttributes().Where(
                a => ( "UnitAttribute" == a?.AttributeClass?.Name ) || ( "Unit" == a?.AttributeClass?.Name )
            );

            var typeSymbols = new List<ITypeSymbol>();
            foreach( AttributeData attribute in attributes )
            {
                // Should never happen, we should get compiler error anyways.
                // There is only one constructor with one argument.
                if( attribute.ConstructorArguments.Length != 1 )
                {
                    continue;
                }

                // This will only work for positional arguments;
                // which the libary only uses anyways.
                TypedConstant type = attribute.ConstructorArguments[0];
                if( type.Kind == TypedConstantKind.Type && type.Value is ITypeSymbol typeSymbol )
                {
                    typeSymbols.Add( typeSymbol );
                }
            }

            return typeSymbols;
        }

        private static void GenerateFor( SourceProductionContext spc, INamedTypeSymbol type )
        {
            var source = BuildSource( type );
            var hint = MakeHintName( type );
            spc.AddSource( hint, source );
        }

        private static string BuildSource( INamedTypeSymbol unitType )
        {
            List<ITypeSymbol> units = GetUnitsType( unitType );
            if( units.Any() == false )
            {
                return $"#error {unitType.Name} did not produce any unit types?";
            }

            var sourceBuilder = new StringBuilder();

            sourceBuilder.AppendLine( "// <auto-generated/>" );
            sourceBuilder.AppendLine( "using System;" );
            sourceBuilder.AppendLine( "namespace K2SRH.Units" );
            sourceBuilder.AppendLine( "{" );

            sourceBuilder.AppendLine( $"    public partial struct {unitType.Name}" );
            sourceBuilder.AppendLine( $"    {{" );
            sourceBuilder.AppendLine( $"        // ---------------- Constructor ----------------" );
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine( $"        public {unitType.Name}( decimal {unitType.Name.ToLower()} )" );
            sourceBuilder.AppendLine( $"        {{" );
            sourceBuilder.AppendLine( $"            this.Value = {unitType.Name.ToLower()};" );
            sourceBuilder.AppendLine( $"        }}" );
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine( $"        // ---------------- Properties ----------------" );
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine( $"        public decimal Value {{ get; }}" );
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine( $"        // ---------------- Methods ----------------" );
            sourceBuilder.AppendLine();

            foreach( ITypeSymbol typeSymbol in units )
            {
                sourceBuilder.AppendLine( GenerateUnitMethods( unitType, typeSymbol ) );
            }

            sourceBuilder.AppendLine( $"    }}" );

            foreach( ITypeSymbol typeSymbol in units )
            {
                sourceBuilder.AppendLine( GenerateExtensionMethods( unitType, typeSymbol ) );
            }

            sourceBuilder.AppendLine( "}" );

            return sourceBuilder.ToString();
        }

        private static string GenerateUnitMethods( INamedTypeSymbol unitType, ITypeSymbol measurementType )
        {
            return $@"
        // -------- {measurementType.Name} --------
    
";
        }

        private static string GenerateExtensionMethods( INamedTypeSymbol unitType, ITypeSymbol measurementType )
        {
            return $@"
    public static partial class {unitType.Name}Extensions
    {{
        public static {unitType.Name} To{unitType.Name}( this {measurementType.Name} {measurementType.Name.ToLower()} )
        {{
            return new {unitType.Name}( {measurementType.Name.ToLower()}.{unitType.Name}() );
        }}
    }}
";
        }

        private static string MakeHintName( INamedTypeSymbol type )
        {
            var name = type.ToDisplayString( SymbolDisplayFormat.FullyQualifiedFormat )
                .Replace( "global::", "" )
                .Replace( '.', '_' )
                .Replace( '<', '_' )
                .Replace( '>', '_' )
                .Replace( ',', '_' )
                .Replace( ' ', '_' );
            return $"{name}_UnitsOperator.g.cs";
        }
    }
}
